---
description: Toutes les rÃ¨gles backend Firebase/PostgreSQL du projet
globs: ["server/**/*.ts"]
alwaysApply: true
---

# ğŸ”¥ RÃˆGLES BACKEND COMPLÃˆTES

## ğŸ—ï¸ ARCHITECTURE BACKEND OBLIGATOIRE
- **Firebase Functions** : Validation cascade (auth â†’ params â†’ workspace â†’ mÃ©tier) + `onCall` configuration
- **Repositories** : Pattern singleton + Pool PostgreSQL + Isolation workspace + Construction lazy
- **RÃ©ponses** : `createResponseWithTokens()` obligatoire + Gestion erreurs + Logger

## ğŸ” SÃ‰CURITÃ‰ NON-NÃ‰GOCIABLE BACKEND
- âœ… **validateAuth(request.auth)** cÃ´tÃ© serveur TOUJOURS en premier
- âœ… **verifyWorkspaceToken()** avec rÃ´les appropriÃ©s
- âœ… **WORKSPACE_ROLES.ADMIN/EDITOR** selon contexte
- âœ… **Secrets Firebase** pour toutes les clÃ©s sensibles
- âŒ **JAMAIS** de donnÃ©es sensibles cÃ´tÃ© client
- âŒ **JAMAIS** de clÃ©s hardcodÃ©es
- âŒ **JAMAIS** d'accÃ¨s direct BDD sans validation workspace

## ğŸ” SÃ‰CURITÃ‰ FONCTIONS onRequest OBLIGATOIRE
- âœ… **Usage INTERNE** : `serverToken` validation obligatoire (Cloud Tasks, cron jobs)
- âœ… **Usage EXTERNE** : `workspaceToken` + `validateIdToken` obligatoire (API publiques)
- âŒ **JAMAIS** de fonction `onRequest` sans aucune sÃ©curitÃ© (sauf webhooks tiers explicites)
- âœ… **Pattern interne** : `const providedToken = request.headers['x-server-token']; if (!providedToken || providedToken !== serverToken.value())`
- âœ… **Pattern externe** : `const idToken = req.headers.authorization?.split('Bearer ')[1]; const workspaceToken = req.headers['x-workspace-token'];`

## ğŸš« ANTI-PATTERNS BACKEND INTERDITS
- âŒ **Functions Firebase sans validateAuth**
- âŒ **AccÃ¨s BDD sans isolation workspace**
- âŒ **RÃ©ponses non standardisÃ©es** (sans createResponseWithTokens)
- âŒ **Erreurs non loggÃ©es**
- âŒ **Secrets non configurÃ©s**
- âŒ **Repositories non-singleton**
- âŒ **Fonctions onRequest sans sÃ©curitÃ©** (ni serverToken ni workspaceToken)
- âŒ **Usage incorrect des tokens** (serverToken pour externe, workspaceToken pour interne)

## âœ… FIREBASE FUNCTION PATTERN OBLIGATOIRE

### âœ… Pattern onCall (standard)
```typescript
export const functionName = onCall({
  // âœ… Configuration complÃ¨te
  secrets: [databaseUrlProd, jwtWorkspaceSecret],
  memory: '512MiB',
  timeoutSeconds: 60
}, async (request) => {
  try {
    // âœ… 1. Validation auth OBLIGATOIRE
    const authResponse = validateAuth(request.auth);
    if (!isSuccess(authResponse)) return authResponse;
    const uid = authResponse.user;

    // âœ… 2. Extraction et validation params
    const { workspaceToken, param1, param2 } = request.data;
    const validationResponse = validateRequiredFields(request.data, [
      'workspaceToken', 'param1'
    ]);
    if (!isSuccess(validationResponse)) return validationResponse;

    // âœ… 3. Validation workspace + rÃ´les
    const tokenValidation = await verifyWorkspaceToken(
      workspaceToken, 
      uid, 
      WORKSPACE_ROLES.EDITOR
    );
    const validationResult = isValidWorkspaceToken(tokenValidation);
    if (!isSuccess(validationResult)) return validationResult;
    const { workspace_id, workspace_tokens } = validationResult;
    const response = createResponseWithTokens(workspace_tokens);

    // âœ… 4. Validation mÃ©tier spÃ©cifique (si nÃ©cessaire)
    if (param1.length > 100) {
      return response.error(ERRORS.INVALID_INPUT);
    }

    // âœ… 5. Logique mÃ©tier via repository
    const result = await getRepository().action(workspace_id, param1, param2);

    // âœ… 6. Logging succÃ¨s
    logger.info(`Action rÃ©ussie pour workspace ${workspace_id} par ${uid}`);

    // âœ… 7. RÃ©ponse standardisÃ©e
    return response.success({ result });
    
  } catch (error) {
    logger.error(`Erreur dans ${functionName.name}:`, error);
    return handleError(error);
  }
});
```

### âœ… Pattern onRequest INTERNE (Cloud Tasks, cron jobs)
```typescript
export const internalFunction = onRequest({
  secrets: [serverToken, databaseUrlProd],
  memory: '512MiB',
  timeoutSeconds: 120
}, async (request, response) => {
  try {
    // âœ… 1. VÃ©rifier mÃ©thode HTTP
    if (request.method !== 'POST') {
      response.status(405).send('Method Not Allowed');
      return;
    }

    // âœ… 2. VALIDATION SERVERTOKEN OBLIGATOIRE
    const providedToken = request.headers['x-server-token'];
    if (!providedToken || providedToken !== serverToken.value()) {
      logger.error('âŒ Token serveur invalide');
      response.status(401).json({ success: false, error: 'Non autorisÃ©' });
      return;
    }

    // âœ… 3. Validation params
    const { workspace_id, param1 } = request.body;
    if (!workspace_id || !param1) {
      response.status(400).send('Bad Request - ParamÃ¨tres manquants');
      return;
    }

    // âœ… 4. Logique mÃ©tier
    const result = await getRepository().action(workspace_id, param1);

    // âœ… 5. RÃ©ponse
    response.status(200).send('OK');
  } catch (error) {
    logger.error('Erreur fonction interne:', error);
    response.status(200).send('OK'); // 200 pour Ã©viter retries Cloud Tasks
  }
});
```

### âœ… Pattern onRequest EXTERNE (API publiques)
```typescript
export const externalFunction = onRequest({
  secrets: [jwtWorkspaceSecret, databaseUrlProd],
  cors: true,
  memory: '512MiB'
}, async (req: Request, res: Response) => {
  try {
    // âœ… 1. CORS Options
    if (req.method === 'OPTIONS') {
      res.status(200).end();
      return;
    }

    // âœ… 2. VALIDATION TOKENS OBLIGATOIRE
    const idToken = req.headers.authorization?.split('Bearer ')[1];
    const workspaceToken = req.headers['x-workspace-token'];

    if (!idToken) {
      res.status(401).json(ERRORS.TOKEN_NOT_FOUND);
      return;
    }
    if (!workspaceToken) {
      res.status(401).json(WORKSPACE_TOKEN_STATE[WorkspaceTokenState.WORKSPACE_TOKEN_NULL]);
      return;
    }

    // âœ… 3. Validation Firebase token
    const tokenValidation = await validateIdToken(idToken);
    if (!isSuccess(tokenValidation)) {
      res.status(401).json(tokenValidation.error);
      return;
    }
    const uid = tokenValidation.user;

    // âœ… 4. Validation workspace token
    const tokenWorkspaceValidation = await verifyWorkspaceToken(
      workspaceToken as string, 
      uid, 
      WORKSPACE_ROLES.EDITOR
    );
    const validationResult = isValidWorkspaceToken(tokenWorkspaceValidation);
    if (!isSuccess(validationResult)) {
      res.status(401).json(validationResult.error);
      return;
    }
    const { workspace_id } = validationResult;

    // âœ… 5. Logique mÃ©tier
    const result = await getRepository().action(workspace_id, req.body);

    // âœ… 6. RÃ©ponse
    res.status(200).json({ success: true, data: result });
  } catch (error) {
    logger.error('Erreur fonction externe:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});
```

## âœ… REPOSITORY PATTERN OBLIGATOIRE
```typescript
export class DomainRepository {
  private pool: Pool;

  constructor() {
    this.pool = getPool(); // âœ… Pool PostgreSQL
  }

  // âœ… MÃ©thodes avec isolation workspace
  async getByWorkspace(workspaceId: string): Promise<DomainType[]> {
    const result = await this.pool.query<DomainType>(
      'SELECT * FROM table_name WHERE workspace_id = $1',
      [workspaceId] // âœ… ParamÃ¨tres prÃ©parÃ©s
    );
    return result.rows;
  }

  // âœ… TOUJOURS rÃ©cupÃ©rer avec workspace pour sÃ©curitÃ©
  async getById(id: string, workspaceId: string): Promise<DomainType | null> {
    const result = await this.pool.query<DomainType>(
      'SELECT * FROM table WHERE id = $1 AND workspace_id = $2',
      [id, workspaceId]
    );
    return result.rows[0] || null;
  }

  async create(workspaceId: string, data: CreateType): Promise<DomainType> {
    const result = await this.pool.query<DomainType>(
      `INSERT INTO table_name (workspace_id, field1, field2)
       VALUES ($1, $2, $3)
       RETURNING *`,
      [workspaceId, data.field1, data.field2]
    );
    return result.rows[0];
  }
}

// âœ… Singleton avec lazy initialization
let domainRepo: DomainRepository | undefined;

export function getDomainRepository(): DomainRepository {
  if (!domainRepo) {
    domainRepo = new DomainRepository();
  }
  return domainRepo;
}
```

## ğŸ” VALIDATION DONNÃ‰ES BACKEND
- âœ… **validateRequiredFields()** avant traitement
- âœ… **Sanitisation** de tous les inputs utilisateur
- âœ… **Validation types** (hex colors, file types, etc.)
- âœ… **ParamÃ¨tres prÃ©parÃ©s** pour SQL
- âŒ **JAMAIS** de concatÃ©nation SQL directe

## ğŸ“ VALIDATION BACKEND PATTERN
```typescript
// âŒ INTERDIT - validateRequiredFields au mauvais endroit
const validationResponse = validateRequiredFields(request.data, ['workspaceToken']);

// âœ… OBLIGATOIRE - CrÃ©er fichier validation + process avant envoi
// Dans un fichier sÃ©parÃ© de validation mÃ©tier
export function validateCampaignData(data: CampaignInput): ValidationResult {
  // Validation spÃ©cifique mÃ©tier
}
```

## ğŸ”§ ENVIRONMENT CONFIGURATION
```typescript
// âœ… Distinction dev/prod obligatoire
const config = process.env.NODE_ENV === 'development' 
  ? DEV_CONFIG : PROD_CONFIG;

// âœ… Ã‰mulateurs Firebase en dev
setGlobalOptions({
  region: process.env.NODE_ENV === 'development' 
    ? 'us-central1' : 'europe-west1'
});
```

## ğŸ”‘ SECRETS MANAGEMENT
```typescript
// âœ… Pattern secrets Firebase
export const mySecret = defineSecret('MY_SECRET_NAME');

// âœ… Usage dans functions
export const myFunction = onCall({
  secrets: [mySecret]
}, async (request) => {
  const value = mySecret.value();
});
```

## ğŸ“Š LOGGING RULES
```typescript
// âœ… Logging structurÃ©
logger.info('Action rÃ©ussie', { 
  workspace_id, 
  user_id, 
  action: 'create_document' 
});

// âœ… Erreurs dÃ©taillÃ©es
logger.error('Erreur validation', { 
  error: error.message,
  stack: error.stack,
  context: { workspace_id, params }
});
```

## ğŸ”§ ERROR HANDLING BACKEND
```typescript
// âœ… Pattern standard
try {
  // logique
} catch (error) {
  logger.error(`Erreur dans ${functionName}:`, error);
  return handleError(error);
}
```

## ğŸ”§ GESTIONNAIRE D'ERREURS CENTRALISÃ‰
```typescript
// âœ… Import obligatoire pour extraction d'erreurs
import { extractErrorMessage, extractErrorMessageFromException, extractErrorMessageFromResponse } from '../utils/errorManager.js';

// âœ… Extraction depuis objet JSON (responseData)
const userMessage = extractErrorMessage(responseData) || 'Message fallback';

// âœ… Extraction depuis Error JavaScript
const userMessage = extractErrorMessageFromException(error);

// âœ… Extraction depuis Response HTTP
const userMessage = await extractErrorMessageFromResponse(response);

// âœ… GÃ¨re automatiquement tous les formats providers :
// - error_user_msg (Facebook/Instagram/Meta standard)
// - error_data.details (WhatsApp spÃ©cifique)
// - error.message (API gÃ©nÃ©rale)
// - message (direct)
```

## ğŸ“Š PERFORMANCE BACKEND
- âœ… **Pool connections** PostgreSQL
- âœ… **Lazy initialization** repositories
- âœ… **ParamÃ¨tres prÃ©parÃ©s** SQL
- âœ… **Pagination** pour listes importantes

## ğŸ§ª TESTING BACKEND
```typescript
// âœ… Tests fonctions Firebase
const mockRequest = {
  auth: { uid: 'test-user' },
  data: { workspaceToken: 'valid-token' }
};

// âœ… Mocks repository
jest.mock('../../db/repositories');
```

## ğŸ—„ï¸ PATTERNS REPOSITORIES DÃ‰TECTÃ‰S

### âœ… Index de repositories centralisÃ©
```typescript
// âœ… Pattern obligatoire dans server/db/repositories/index.ts
let domainRepo: DomainRepository | undefined;

export function getDomainRepository(): DomainRepository {
  if (!domainRepo) {
    domainRepo = new DomainRepository();
  }
  return domainRepo;
}
```

### âœ… Isolation workspace systÃ©matique
```typescript
// âœ… Pattern dÃ©tectÃ© : TOUJOURS workspace en premier param
async getItemsByWorkspace(
  workspaceId: string,
  params: { cursor?: Cursor; limit?: number; agentId?: string }
): Promise<Response> {
  // RequÃªte avec workspace_id = $1
}
```

## ğŸ”¥ PATTERNS FIREBASE FUNCTIONS DÃ‰TECTÃ‰S

### âœ… Protection dev/prod
```typescript
// âœ… Pattern dÃ©tectÃ© dans devService.ts
if (process.env.NODE_ENV !== 'development') {
  throw new Error('âŒ ERREUR CRITIQUE : devService.ts ne doit jamais Ãªtre dÃ©ployÃ© en production !');
}
```

### âœ… Configuration Firebase complÃ¨te
```typescript
// âœ… Pattern dÃ©tectÃ© dans temporaryFileService.ts
export const serviceName = onCall({
  secrets: [requiredSecret, anotherSecret],
  memory: '512MiB',
  timeoutSeconds: 60
}, async (request) => {
  // Implementation avec validation cascade
});
```

### âœ… Validation cascade standardisÃ©e
```typescript
// âœ… Pattern dÃ©tectÃ© : ordre obligatoire
try {
  // 1ï¸âƒ£ Validation auth OBLIGATOIRE
  const authResponse = validateAuth(request.auth);
  if (!isSuccess(authResponse)) return authResponse;

  // 2ï¸âƒ£ Validation params requis
  const validationResponse = validateRequiredFields(request.data, ['field1']);
  if (!isSuccess(validationResponse)) return validationResponse;

  // 3ï¸âƒ£ Validation workspace (si nÃ©cessaire)
  const tokenValidation = await verifyWorkspaceToken(token, uid, role);
  // ...

  // 4ï¸âƒ£ Validation mÃ©tier spÃ©cifique
  // 5ï¸âƒ£ Logique mÃ©tier
  // 6ï¸âƒ£ Logging succÃ¨s
  // 7ï¸âƒ£ RÃ©ponse standardisÃ©e
} catch (error) {
  logger.error('Erreur dans serviceName:', error);
  return handleError(error);
}
```

## ğŸ”§ PATTERNS VALIDATION DÃ‰TECTÃ‰S

### âœ… Validation couleurs hex
```typescript
// âœ… Pattern dÃ©tectÃ© dans validation.ts
export function validateOptionalHexColor(color?: string | null): boolean {
  if (!color) return true;
  return /^#[0-9A-Fa-f]{6}$/.test(color);
}
```

### âœ… Validation contraintes mÃ©tier
```typescript
// âœ… Pattern dÃ©tectÃ© : validation spÃ©cifique par type
export function validateDocumentConstraints(data: {
  type: DocumentType;
  name?: string | null;
  description?: string | null;
  url?: string | null;
  corpus_document_id?: string | null;
}): boolean {
  switch (type) {
    case DocumentType.INFO:
      return name !== null && description !== null && 
             url === null && corpus_document_id === null;
    // Autres cas...
  }
}
```

### âœ… Gestion dev/prod dans validation
```typescript
// âœ… Pattern dÃ©tectÃ© dans validateIdToken
if (process.env.NODE_ENV === 'development') {
  // Mode dÃ©veloppement : dÃ©coder sans vÃ©rifier
  try {
    const decoded: any = jwt.decode(idToken, { complete: false });
    // ...
  } catch (error) {
    return { success: true, user: 'dev-user' }; // Fallback dev
  }
}
// Production : vÃ©rification stricte
```

## âš ï¸ Firebase Functions protection
- âœ… **NODE_ENV checks** : Obligatoire pour fonctions dev-only
- âœ… **Environment-specific secrets** : DiffÃ©rents secrets dev/prod

### âš ï¸ Validation cascade order
- âœ… **7-step pattern** : Auth â†’ Params â†’ Workspace â†’ MÃ©tier â†’ Logic â†’ Log â†’ Response
- âœ… **Error numbering** : Commentaires 1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£ pour clartÃ©

### âš ï¸ Dev/Prod handling
- âœ… **Emulator configuration** : us-central1 dev, europe-west1 prod
- âœ… **Token validation** : Strict en prod, permissif en dev avec fallbacks

## ğŸ”§ TYPES ET VARIABLES RULES CRITIQUES

### âœ… TYPES OBLIGATOIRES
- âœ… **Types spÃ©cifiques** : TOUJOURS utiliser les types dÃ©finis (`CustomAgentNotificationConfig` au lieu de `Record<string, any>`)
- âœ… **Types shared/types.ts** : TOUS les types partagÃ©s DOIVENT Ãªtre dans `shared/types.ts`
- âœ… **Import correct** : `import { Type1, Type2 } from '../../../shared/types'`
- âŒ **JAMAIS any** : Utiliser `unknown` si type inconnu

### âŒ VARIABLES NON UTILISÃ‰ES INTERDITES
```typescript
// âŒ INTERDIT - Variable non utilisÃ©e
const unusedVariable = someValue; // Variable jamais utilisÃ©e dans le code

// âŒ INTERDIT - Import non utilisÃ©  
import { UnusedType } from './types'; // Import jamais utilisÃ©

// âœ… CORRECT - Toutes variables utilisÃ©es
const usedVariable = someValue;
console.log(usedVariable); // Variable utilisÃ©e
```

### âœ… REPOSITORY TYPES PATTERN OBLIGATOIRE
```typescript
// âŒ AVANT - Types gÃ©nÃ©riques
async create(
  workspaceId: string,
  config: Record<string, any>  // âŒ Type gÃ©nÃ©rique
): Promise<Entity>

// âœ… APRÃˆS - Types spÃ©cifiques
async create(
  workspaceId: string,
  config: CustomAgentNotificationConfig  // âœ… Type spÃ©cifique
): Promise<CustomAgentNotification>
```

## ğŸ—ï¸ ARCHITECTURE DOSSIERS SERVER OBLIGATOIRE (miroir ARCHITECTURE.md)

La structure du dossier `server/` DOIT correspondre Ã  `server/ARCHITECTURE.md`.

```
server/
â”œâ”€â”€ db/                    # ğŸ—„ï¸ Couche donnÃ©es
â”‚   â”œâ”€â”€ prisma/           # SchÃ©mas et migrations Prisma
â”‚   â”‚   â”œâ”€â”€ schema.prisma # ModÃ¨les de donnÃ©es
â”‚   â”‚   â””â”€â”€ migrations/   # Migrations SQL
â”‚   â”œâ”€â”€ repositories/     # Pattern Repository
â”‚   â””â”€â”€ config.ts         # Configuration base de donnÃ©es
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ routes/                # onRequest (HTTP/webhooks) protÃ©gÃ©s
â”‚   â”œâ”€â”€ services/              # onCall/onRequest (cascade 7 Ã©tapes)
â”‚   â”œâ”€â”€ utils/                 # validation.ts, authWorkspace.ts, migrate.ts, ...
â”‚   â”œâ”€â”€ triggers/              # Triggers Firebase
â”‚   â””â”€â”€ main.ts                # setGlobalOptions + defineSecret + init admin
â”œâ”€â”€ shared/
â”‚   â””â”€â”€ types/                 # Types backend spÃ©cifiques
â””â”€â”€ ../shared/                 # Types fullâ€‘stack (types.ts, colors.ts, ...)
```

### âœ… Migrations base de donnÃ©es
- Fichiers SQL dans `server/db/migrations/` (ordre lexical, idempotents).
- Runner obligatoire (ex: `server/src/utils/migrate.ts`) ou Prisma `migrate`.
- Script NPM requis: `npm run migrate` â†’ applique toutes les migrations.

### âœ… Exigences Configuration
- `setGlobalOptions`: dev â†’ `us-central1`, prod â†’ `europe-west1`.
- Secrets via `defineSecret` (ex: `DATABASE_URL`, `JWT_WORKSPACE_SECRET`).
- En Ã©mulateur: fournir secrets via `server/.secret.local` (clÃ©=valeur).

### âœ… ConformitÃ© Functions
- onCall/onRequest DOIVENT importer/utiliser `createResponseWithTokens()`.
- Cascade 7 Ã©tapes obligatoire (auth â†’ params â†’ workspace â†’ mÃ©tier â†’ log â†’ response).
- Repositories: `WHERE workspace_id = $1`, paramÃ¨tres prÃ©parÃ©s, singleton lazy via `db/repositories/index.ts`.
