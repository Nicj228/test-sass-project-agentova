---
description: Toutes les r√®gles backend Firebase/PostgreSQL du projet
globs: ["server/**/*.ts"]
alwaysApply: true
---

# üî• R√àGLES BACKEND COMPL√àTES

## üèóÔ∏è ARCHITECTURE BACKEND OBLIGATOIRE
- **Firebase Functions** : Validation cascade (auth ‚Üí params ‚Üí workspace ‚Üí m√©tier) + `onCall` configuration
- **Repositories** : Pattern singleton + Pool PostgreSQL + Isolation workspace + Construction lazy
- **R√©ponses** : `createResponseWithTokens()` obligatoire + Gestion erreurs + Logger

## üîê S√âCURIT√â NON-N√âGOCIABLE BACKEND
- ‚úÖ **validateAuth(request.auth)** c√¥t√© serveur TOUJOURS en premier
- ‚úÖ **verifyWorkspaceToken()** avec r√¥les appropri√©s
- ‚úÖ **WORKSPACE_ROLES.ADMIN/EDITOR** selon contexte
- ‚úÖ **Secrets Firebase** pour toutes les cl√©s sensibles
- ‚ùå **JAMAIS** de donn√©es sensibles c√¥t√© client
- ‚ùå **JAMAIS** de cl√©s hardcod√©es
- ‚ùå **JAMAIS** d'acc√®s direct BDD sans validation workspace

## üîê S√âCURIT√â FONCTIONS onRequest OBLIGATOIRE
- ‚úÖ **Usage INTERNE** : `serverToken` validation obligatoire (Cloud Tasks, cron jobs)
- ‚úÖ **Usage EXTERNE** : `workspaceToken` + `validateIdToken` obligatoire (API publiques)
- ‚ùå **JAMAIS** de fonction `onRequest` sans aucune s√©curit√© (sauf webhooks tiers explicites)
- ‚úÖ **Pattern interne** : `const providedToken = request.headers['x-server-token']; if (!providedToken || providedToken !== serverToken.value())`
- ‚úÖ **Pattern externe** : `const idToken = req.headers.authorization?.split('Bearer ')[1]; const workspaceToken = req.headers['x-workspace-token'];`

## üö´ ANTI-PATTERNS BACKEND INTERDITS
- ‚ùå **Functions Firebase sans validateAuth**
- ‚ùå **Acc√®s BDD sans isolation workspace**
- ‚ùå **R√©ponses non standardis√©es** (sans createResponseWithTokens)
- ‚ùå **Erreurs non logg√©es**
- ‚ùå **Secrets non configur√©s**
- ‚ùå **Repositories non-singleton**
- ‚ùå **Fonctions onRequest sans s√©curit√©** (ni serverToken ni workspaceToken)
- ‚ùå **Usage incorrect des tokens** (serverToken pour externe, workspaceToken pour interne)

## ‚úÖ FIREBASE FUNCTION PATTERN OBLIGATOIRE

### ‚úÖ Pattern onCall (standard)
```typescript
export const functionName = onCall({
  // ‚úÖ Configuration compl√®te
  secrets: [databaseUrlProd, jwtWorkspaceSecret],
  memory: '512MiB',
  timeoutSeconds: 60
}, async (request) => {
  try {
    // ‚úÖ 1. Validation auth OBLIGATOIRE
    const authResponse = validateAuth(request.auth);
    if (!isSuccess(authResponse)) return authResponse;
    const uid = authResponse.user;

    // ‚úÖ 2. Extraction et validation params
    const { workspaceToken, param1, param2 } = request.data;
    const validationResponse = validateRequiredFields(request.data, [
      'workspaceToken', 'param1'
    ]);
    if (!isSuccess(validationResponse)) return validationResponse;

    // ‚úÖ 3. Validation workspace + r√¥les
    const tokenValidation = await verifyWorkspaceToken(
      workspaceToken, 
      uid, 
      WORKSPACE_ROLES.EDITOR
    );
    const validationResult = isValidWorkspaceToken(tokenValidation);
    if (!isSuccess(validationResult)) return validationResult;
    const { workspace_id, workspace_tokens } = validationResult;
    const response = createResponseWithTokens(workspace_tokens);

    // ‚úÖ 4. Validation m√©tier sp√©cifique (si n√©cessaire)
    if (param1.length > 100) {
      return response.error(ERRORS.INVALID_INPUT);
    }

    // ‚úÖ 5. Logique m√©tier via repository
    const result = await getRepository().action(workspace_id, param1, param2);

    // ‚úÖ 6. Logging succ√®s
    logger.info(`Action r√©ussie pour workspace ${workspace_id} par ${uid}`);

    // ‚úÖ 7. R√©ponse standardis√©e
    return response.success({ result });
    
  } catch (error) {
    logger.error(`Erreur dans ${functionName.name}:`, error);
    return handleError(error);
  }
});
```

### ‚úÖ Pattern onRequest INTERNE (Cloud Tasks, cron jobs)
```typescript
export const internalFunction = onRequest({
  secrets: [serverToken, databaseUrlProd],
  memory: '512MiB',
  timeoutSeconds: 120
}, async (request, response) => {
  try {
    // ‚úÖ 1. V√©rifier m√©thode HTTP
    if (request.method !== 'POST') {
      response.status(405).send('Method Not Allowed');
      return;
    }

    // ‚úÖ 2. VALIDATION SERVERTOKEN OBLIGATOIRE
    const providedToken = request.headers['x-server-token'];
    if (!providedToken || providedToken !== serverToken.value()) {
      logger.error('‚ùå Token serveur invalide');
      response.status(401).json({ success: false, error: 'Non autoris√©' });
      return;
    }

    // ‚úÖ 3. Validation params
    const { workspace_id, param1 } = request.body;
    if (!workspace_id || !param1) {
      response.status(400).send('Bad Request - Param√®tres manquants');
      return;
    }

    // ‚úÖ 4. Logique m√©tier
    const result = await getRepository().action(workspace_id, param1);

    // ‚úÖ 5. R√©ponse
    response.status(200).send('OK');
  } catch (error) {
    logger.error('Erreur fonction interne:', error);
    response.status(200).send('OK'); // 200 pour √©viter retries Cloud Tasks
  }
});
```

### ‚úÖ Pattern onRequest EXTERNE (API publiques)
```typescript
export const externalFunction = onRequest({
  secrets: [jwtWorkspaceSecret, databaseUrlProd],
  cors: true,
  memory: '512MiB'
}, async (req: Request, res: Response) => {
  try {
    // ‚úÖ 1. CORS Options
    if (req.method === 'OPTIONS') {
      res.status(200).end();
      return;
    }

    // ‚úÖ 2. VALIDATION TOKENS OBLIGATOIRE
    const idToken = req.headers.authorization?.split('Bearer ')[1];
    const workspaceToken = req.headers['x-workspace-token'];

    if (!idToken) {
      res.status(401).json(ERRORS.TOKEN_NOT_FOUND);
      return;
    }
    if (!workspaceToken) {
      res.status(401).json(WORKSPACE_TOKEN_STATE[WorkspaceTokenState.WORKSPACE_TOKEN_NULL]);
      return;
    }

    // ‚úÖ 3. Validation Firebase token
    const tokenValidation = await validateIdToken(idToken);
    if (!isSuccess(tokenValidation)) {
      res.status(401).json(tokenValidation.error);
      return;
    }
    const uid = tokenValidation.user;

    // ‚úÖ 4. Validation workspace token
    const tokenWorkspaceValidation = await verifyWorkspaceToken(
      workspaceToken as string, 
      uid, 
      WORKSPACE_ROLES.EDITOR
    );
    const validationResult = isValidWorkspaceToken(tokenWorkspaceValidation);
    if (!isSuccess(validationResult)) {
      res.status(401).json(validationResult.error);
      return;
    }
    const { workspace_id } = validationResult;

    // ‚úÖ 5. Logique m√©tier
    const result = await getRepository().action(workspace_id, req.body);

    // ‚úÖ 6. R√©ponse
    res.status(200).json({ success: true, data: result });
  } catch (error) {
    logger.error('Erreur fonction externe:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});
```

## ‚úÖ REPOSITORY PATTERN OBLIGATOIRE
```typescript
export class DomainRepository {
  private pool: Pool;

  constructor() {
    this.pool = getPool(); // ‚úÖ Pool PostgreSQL
  }

  // ‚úÖ M√©thodes avec isolation workspace
  async getByWorkspace(workspaceId: string): Promise<DomainType[]> {
    const result = await this.pool.query<DomainType>(
      'SELECT * FROM table_name WHERE workspace_id = $1',
      [workspaceId] // ‚úÖ Param√®tres pr√©par√©s
    );
    return result.rows;
  }

  // ‚úÖ TOUJOURS r√©cup√©rer avec workspace pour s√©curit√©
  async getById(id: string, workspaceId: string): Promise<DomainType | null> {
    const result = await this.pool.query<DomainType>(
      'SELECT * FROM table WHERE id = $1 AND workspace_id = $2',
      [id, workspaceId]
    );
    return result.rows[0] || null;
  }

  async create(workspaceId: string, data: CreateType): Promise<DomainType> {
    const result = await this.pool.query<DomainType>(
      `INSERT INTO table_name (workspace_id, field1, field2)
       VALUES ($1, $2, $3)
       RETURNING *`,
      [workspaceId, data.field1, data.field2]
    );
    return result.rows[0];
  }
}

// ‚úÖ Singleton avec lazy initialization
let domainRepo: DomainRepository | undefined;

export function getDomainRepository(): DomainRepository {
  if (!domainRepo) {
    domainRepo = new DomainRepository();
  }
  return domainRepo;
}
```

## üîê VALIDATION DONN√âES BACKEND
- ‚úÖ **validateRequiredFields()** avant traitement
- ‚úÖ **Sanitisation** de tous les inputs utilisateur
- ‚úÖ **Validation types** (hex colors, file types, etc.)
- ‚úÖ **Param√®tres pr√©par√©s** pour SQL
- ‚ùå **JAMAIS** de concat√©nation SQL directe

## üìù VALIDATION BACKEND PATTERN
```typescript
// ‚ùå INTERDIT - validateRequiredFields au mauvais endroit
const validationResponse = validateRequiredFields(request.data, ['workspaceToken']);

// ‚úÖ OBLIGATOIRE - Cr√©er fichier validation + process avant envoi
// Dans un fichier s√©par√© de validation m√©tier
export function validateCampaignData(data: CampaignInput): ValidationResult {
  // Validation sp√©cifique m√©tier
}
```

## üîß ENVIRONMENT CONFIGURATION
```typescript
// ‚úÖ Distinction dev/prod obligatoire
const config = process.env.NODE_ENV === 'development' 
  ? DEV_CONFIG : PROD_CONFIG;

// ‚úÖ √âmulateurs Firebase en dev
setGlobalOptions({
  region: process.env.NODE_ENV === 'development' 
    ? 'us-central1' : 'europe-west1'
});
```

## üîë SECRETS MANAGEMENT
```typescript
// ‚úÖ Pattern secrets Firebase
export const mySecret = defineSecret('MY_SECRET_NAME');

// ‚úÖ Usage dans functions
export const myFunction = onCall({
  secrets: [mySecret]
}, async (request) => {
  const value = mySecret.value();
});
```

## üìä LOGGING RULES
```typescript
// ‚úÖ Logging structur√©
logger.info('Action r√©ussie', { 
  workspace_id, 
  user_id, 
  action: 'create_document' 
});

// ‚úÖ Erreurs d√©taill√©es
logger.error('Erreur validation', { 
  error: error.message,
  stack: error.stack,
  context: { workspace_id, params }
});
```

## üîß ERROR HANDLING BACKEND
```typescript
// ‚úÖ Pattern standard
try {
  // logique
} catch (error) {
  logger.error(`Erreur dans ${functionName}:`, error);
  return handleError(error);
}
```

## üîß GESTIONNAIRE D'ERREURS CENTRALIS√â
```typescript
// ‚úÖ Import obligatoire pour extraction d'erreurs
import { extractErrorMessage, extractErrorMessageFromException, extractErrorMessageFromResponse } from '../utils/errorManager.js';

// ‚úÖ Extraction depuis objet JSON (responseData)
const userMessage = extractErrorMessage(responseData) || 'Message fallback';

// ‚úÖ Extraction depuis Error JavaScript
const userMessage = extractErrorMessageFromException(error);

// ‚úÖ Extraction depuis Response HTTP
const userMessage = await extractErrorMessageFromResponse(response);

// ‚úÖ G√®re automatiquement tous les formats providers :
// - error_user_msg (Facebook/Instagram/Meta standard)
// - error_data.details (WhatsApp sp√©cifique)
// - error.message (API g√©n√©rale)
// - message (direct)
```

## üìä PERFORMANCE BACKEND
- ‚úÖ **Pool connections** PostgreSQL
- ‚úÖ **Lazy initialization** repositories
- ‚úÖ **Param√®tres pr√©par√©s** SQL
- ‚úÖ **Pagination** pour listes importantes

## üß™ TESTING BACKEND
```typescript
// ‚úÖ Tests fonctions Firebase
const mockRequest = {
  auth: { uid: 'test-user' },
  data: { workspaceToken: 'valid-token' }
};

// ‚úÖ Mocks repository
jest.mock('../../db/repositories');
```

## üóÑÔ∏è PATTERNS REPOSITORIES D√âTECT√âS

### ‚úÖ Index de repositories centralis√©
```typescript
// ‚úÖ Pattern obligatoire dans server/db/repositories/index.ts
let domainRepo: DomainRepository | undefined;

export function getDomainRepository(): DomainRepository {
  if (!domainRepo) {
    domainRepo = new DomainRepository();
  }
  return domainRepo;
}
```

### ‚úÖ Isolation workspace syst√©matique
```typescript
// ‚úÖ Pattern d√©tect√© : TOUJOURS workspace en premier param
async getItemsByWorkspace(
  workspaceId: string,
  params: { cursor?: Cursor; limit?: number; agentId?: string }
): Promise<Response> {
  // Requ√™te avec workspace_id = $1
}
```

## üî• PATTERNS FIREBASE FUNCTIONS D√âTECT√âS

### ‚úÖ Protection dev/prod
```typescript
// ‚úÖ Pattern d√©tect√© dans devService.ts
if (process.env.NODE_ENV !== 'development') {
  throw new Error('‚ùå ERREUR CRITIQUE : devService.ts ne doit jamais √™tre d√©ploy√© en production !');
}
```

### ‚úÖ Configuration Firebase compl√®te
```typescript
// ‚úÖ Pattern d√©tect√© dans temporaryFileService.ts
export const serviceName = onCall({
  secrets: [requiredSecret, anotherSecret],
  memory: '512MiB',
  timeoutSeconds: 60
}, async (request) => {
  // Implementation avec validation cascade
});
```

### ‚úÖ Validation cascade standardis√©e
```typescript
// ‚úÖ Pattern d√©tect√© : ordre obligatoire
try {
  // 1Ô∏è‚É£ Validation auth OBLIGATOIRE
  const authResponse = validateAuth(request.auth);
  if (!isSuccess(authResponse)) return authResponse;

  // 2Ô∏è‚É£ Validation params requis
  const validationResponse = validateRequiredFields(request.data, ['field1']);
  if (!isSuccess(validationResponse)) return validationResponse;

  // 3Ô∏è‚É£ Validation workspace (si n√©cessaire)
  const tokenValidation = await verifyWorkspaceToken(token, uid, role);
  // ...

  // 4Ô∏è‚É£ Validation m√©tier sp√©cifique
  // 5Ô∏è‚É£ Logique m√©tier
  // 6Ô∏è‚É£ Logging succ√®s
  // 7Ô∏è‚É£ R√©ponse standardis√©e
} catch (error) {
  logger.error('Erreur dans serviceName:', error);
  return handleError(error);
}
```

## üîß PATTERNS VALIDATION D√âTECT√âS

### ‚úÖ Validation couleurs hex
```typescript
// ‚úÖ Pattern d√©tect√© dans validation.ts
export function validateOptionalHexColor(color?: string | null): boolean {
  if (!color) return true;
  return /^#[0-9A-Fa-f]{6}$/.test(color);
}
```

### ‚úÖ Validation contraintes m√©tier
```typescript
// ‚úÖ Pattern d√©tect√© : validation sp√©cifique par type
export function validateDocumentConstraints(data: {
  type: DocumentType;
  name?: string | null;
  description?: string | null;
  url?: string | null;
  corpus_document_id?: string | null;
}): boolean {
  switch (type) {
    case DocumentType.INFO:
      return name !== null && description !== null && 
             url === null && corpus_document_id === null;
    // Autres cas...
  }
}
```

### ‚úÖ Gestion dev/prod dans validation
```typescript
// ‚úÖ Pattern d√©tect√© dans validateIdToken
if (process.env.NODE_ENV === 'development') {
  // Mode d√©veloppement : d√©coder sans v√©rifier
  try {
    const decoded: any = jwt.decode(idToken, { complete: false });
    // ...
  } catch (error) {
    return { success: true, user: 'dev-user' }; // Fallback dev
  }
}
// Production : v√©rification stricte
```

## ‚ö†Ô∏è Firebase Functions protection
- ‚úÖ **NODE_ENV checks** : Obligatoire pour fonctions dev-only
- ‚úÖ **Environment-specific secrets** : Diff√©rents secrets dev/prod

### ‚ö†Ô∏è Validation cascade order
- ‚úÖ **7-step pattern** : Auth ‚Üí Params ‚Üí Workspace ‚Üí M√©tier ‚Üí Logic ‚Üí Log ‚Üí Response
- ‚úÖ **Error numbering** : Commentaires 1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£ pour clart√©

### ‚ö†Ô∏è Dev/Prod handling
- ‚úÖ **Emulator configuration** : us-central1 dev, europe-west1 prod
- ‚úÖ **Token validation** : Strict en prod, permissif en dev avec fallbacks

## üîß TYPES ET VARIABLES RULES CRITIQUES

### ‚úÖ TYPES OBLIGATOIRES
- ‚úÖ **Types sp√©cifiques** : TOUJOURS utiliser les types d√©finis (`CustomAgentNotificationConfig` au lieu de `Record<string, any>`)
- ‚úÖ **Types shared/types.ts** : TOUS les types partag√©s DOIVENT √™tre dans `shared/types.ts`
- ‚úÖ **Import correct** : `import { Type1, Type2 } from '../../../shared/types'`
- ‚ùå **JAMAIS any** : Utiliser `unknown` si type inconnu

### ‚ùå VARIABLES NON UTILIS√âES INTERDITES
```typescript
// ‚ùå INTERDIT - Variable non utilis√©e
const unusedVariable = someValue; // Variable jamais utilis√©e dans le code

// ‚ùå INTERDIT - Import non utilis√©  
import { UnusedType } from './types'; // Import jamais utilis√©

// ‚úÖ CORRECT - Toutes variables utilis√©es
const usedVariable = someValue;
console.log(usedVariable); // Variable utilis√©e
```

### ‚úÖ REPOSITORY TYPES PATTERN OBLIGATOIRE
```typescript
// ‚ùå AVANT - Types g√©n√©riques
async create(
  workspaceId: string,
  config: Record<string, any>  // ‚ùå Type g√©n√©rique
): Promise<Entity>

// ‚úÖ APR√àS - Types sp√©cifiques
async create(
  workspaceId: string,
  config: CustomAgentNotificationConfig  // ‚úÖ Type sp√©cifique
): Promise<CustomAgentNotification>
```
